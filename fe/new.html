<!DOCTYPE html>
<html>
<head>
    <title>RealtimeSTT Browser Client</title>
    <meta charset="UTF-8">
    <style>
        html, body {
            height: 100%;
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }
        body {
            background-color: black;
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 20px;
            box-sizing: border-box;
        }
        .container {
            max-width: 800px;
            width: 100%;
            margin: auto;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        #controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        button, input {
            padding: 10px 15px;
            font-size: 16px;
            border-radius: 5px;
            border: 1px solid #555;
            background-color: #333;
            color: white;
            cursor: pointer;
        }
        button:disabled {
            background-color: #555;
            cursor: not-allowed;
        }
        #textDisplay {
            white-space: pre-wrap;
            font-size: 1.2em;
            text-align: left;
            background-color: #1a1a1a;
            padding: 20px;
            border-radius: 8px;
            min-height: 100px;
            line-height: 1.6;
        }
        #progressContainer {
            width: 100%;
            background-color: #333;
            border-radius: 5px;
            display: none;
        }
        #progressBar {
            width: 0%;
            height: 20px;
            background-color: #4CAF50;
            border-radius: 5px;
            transition: width 0.3s;
        }
        #status {
            font-size: 1.1em;
            color: #aaa;
        }
        .error {
            color: #ff4d4d;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>RealtimeSTT WebSocket Demo</h1>
        <div id="controls">
            <button id="micButton">Start Microphone</button>
            <input type="file" id="audioFileInput" accept="audio/*" style="display: none;">
            <button onclick="document.getElementById('audioFileInput').click();">Select Audio File</button>
            <button id="streamFileButton" disabled>Stream File</button>
            <button id="pauseFileButton" disabled>Pause File</button>
            <button id="cancelFileButton" disabled>Cancel File</button>
        </div>
        <div id="status">Connecting to server...</div>
        <div id="progressContainer">
            <div id="progressBar"></div>
        </div>
        <div id="textDisplay"></div>
    </div>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const micButton = document.getElementById('micButton');
            const fileInput = document.getElementById('audioFileInput');
            const streamFileButton = document.getElementById('streamFileButton');
            const pauseFileButton = document.getElementById('pauseFileButton');
            const cancelFileButton = document.getElementById('cancelFileButton');
            const textDisplay = document.getElementById('textDisplay');
            const statusDisplay = document.getElementById('status');
            const progressContainer = document.getElementById('progressContainer');
            const progressBar = document.getElementById('progressBar');

            let socket;
            let audioContext;
            let scriptProcessor;
            let mediaStream;
            let isStreaming = false;
            let isFileStreaming = false;
            let isFilePaused = false;
            let audioElement;
            let fileSource;
            let fileScriptProcessor;
            let fileAudioContext;

            const CHUNK_SIZE = 2048; // Kích thước chunk để gửi đi
            const TARGET_SAMPLE_RATE = 16000;

            function connectWebSocket() {
                socket = new WebSocket('ws://localhost:8989');

                socket.onopen = () => {
                    statusDisplay.textContent = 'Connected. Ready to stream.';
                    console.log('WebSocket connection established.');
                    micButton.disabled = false;
                };

                socket.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    if (data.type === 'realtime') {
                        textDisplay.textContent = data.text;
                    } else if (data.type === 'fullSentence') {
                        textDisplay.textContent = data.text;
                        console.log('Full sentence:', data.text);
                    }
                };

                socket.onclose = () => {
                    statusDisplay.textContent = 'Disconnected. Trying to reconnect...';
                    console.log('WebSocket connection closed. Reconnecting...');
                    setTimeout(connectWebSocket, 2000); // Thử kết nối lại sau 2 giây
                };

                socket.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    statusDisplay.textContent = 'Connection error.';
                    statusDisplay.classList.add('error');
                    socket.close();
                };
            }

            function sendAudioData(chunk, sampleRate) {
                if (socket && socket.readyState === WebSocket.OPEN) {
                    const metadata = { sampleRate: sampleRate };
                    const metadataJson = JSON.stringify(metadata);
                    const metadataLength = new TextEncoder().encode(metadataJson).length;

                    const header = new ArrayBuffer(4);
                    new DataView(header).setUint32(0, metadataLength, true);

                    const message = new Blob([header, metadataJson, chunk]);
                    socket.send(message);
                }
            }

            async function startMicrophone() {
                if (isStreaming) return;
                isStreaming = true;
                micButton.textContent = 'Stop Microphone';

                audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: TARGET_SAMPLE_RATE });
                mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                
                const source = audioContext.createMediaStreamSource(mediaStream);
                scriptProcessor = audioContext.createScriptProcessor(CHUNK_SIZE, 1, 1);

                scriptProcessor.onaudioprocess = (e) => {
                    const inputData = e.inputBuffer.getChannelData(0);
                    const pcm16 = new Int16Array(inputData.length);
                    for (let i = 0; i < inputData.length; i++) {
                        pcm16[i] = Math.max(-32768, Math.min(32767, inputData[i] * 32767));
                    }
                    sendAudioData(pcm16.buffer, audioContext.sampleRate);
                };

                source.connect(scriptProcessor);
                scriptProcessor.connect(audioContext.destination);
                statusDisplay.textContent = 'Streaming from microphone...';
                statusDisplay.classList.remove('error');
            }

            function stopMicrophone() {
                if (!isStreaming) return;
                isStreaming = false;
                micButton.textContent = 'Start Microphone';

                if (mediaStream) {
                    mediaStream.getTracks().forEach(track => track.stop());
                }
                if (scriptProcessor) {
                    scriptProcessor.disconnect();
                }
                if (audioContext) {
                    audioContext.close();
                }
                statusDisplay.textContent = 'Microphone stopped.';
            }

            micButton.addEventListener('click', () => {
                if (isStreaming) {
                    stopMicrophone();
                } else {
                    startMicrophone();
                }
            });

            fileInput.addEventListener('change', (event) => {
                if (event.target.files.length > 0) {
                    const file = event.target.files[0];
                    if (!file.type.startsWith('audio/')) {
                        statusDisplay.textContent = 'Invalid file type. Please select an audio file.';
                        statusDisplay.classList.add('error');
                        streamFileButton.disabled = true;
                        return;
                    }
                    streamFileButton.disabled = false;
                    statusDisplay.textContent = `File selected: ${file.name}`;
                    statusDisplay.classList.remove('error');
                }
            });

            streamFileButton.addEventListener('click', async () => {
                const file = fileInput.files[0];
                if (!file) {
                    alert('Please select an audio file first.');
                    return;
                }

                if (isStreaming) {
                    stopMicrophone();
                }

                isFileStreaming = true;
                streamFileButton.disabled = true;
                pauseFileButton.disabled = false;
                pauseFileButton.textContent = 'Pause File';
                cancelFileButton.disabled = false;
                micButton.disabled = true;
                statusDisplay.textContent = 'Processing and streaming file...';
                progressContainer.style.display = 'block';
                progressBar.style.width = '0%';

                audioElement = new Audio(URL.createObjectURL(file));
                audioElement.playbackRate = 1.0;

                fileAudioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: TARGET_SAMPLE_RATE });
                fileSource = fileAudioContext.createMediaElementSource(audioElement);
                fileScriptProcessor = fileAudioContext.createScriptProcessor(CHUNK_SIZE, 1, 1);

                fileScriptProcessor.onaudioprocess = (e) => {
                    const inputData = e.inputBuffer.getChannelData(0);
                    const pcm16 = new Int16Array(inputData.length);
                    for (let i = 0; i < inputData.length; i++) {
                        pcm16[i] = Math.max(-32768, Math.min(32767, inputData[i] * 32767));
                    }
                    sendAudioData(pcm16.buffer, fileAudioContext.sampleRate);
                };

                fileSource.connect(fileScriptProcessor);
                fileScriptProcessor.connect(fileAudioContext.destination);

                audioElement.ontimeupdate = () => {
                    const progress = (audioElement.currentTime / audioElement.duration) * 100;
                    progressBar.style.width = `${progress}%`;
                };

                audioElement.onended = () => {
                    stopFileStreaming();
                    statusDisplay.textContent = 'File streaming finished.';
                };

                try {
                    await audioElement.play();
                } catch (error) {
                    statusDisplay.textContent = 'Error playing file: ' + error.message;
                    statusDisplay.classList.add('error');
                    stopFileStreaming();
                }
            });

            pauseFileButton.addEventListener('click', () => {
                if (!isFileStreaming) return;
                if (isFilePaused) {
                    audioElement.play();
                    pauseFileButton.textContent = 'Pause File';
                    statusDisplay.textContent = 'Resuming file streaming...';
                } else {
                    audioElement.pause();
                    pauseFileButton.textContent = 'Resume File';
                    statusDisplay.textContent = 'File streaming paused.';
                }
                isFilePaused = !isFilePaused;
            });

            cancelFileButton.addEventListener('click', () => {
                if (!isFileStreaming) return;
                stopFileStreaming();
                statusDisplay.textContent = 'File streaming cancelled.';
            });

            function stopFileStreaming() {
                isFileStreaming = false;
                isFilePaused = false;
                streamFileButton.disabled = false;
                pauseFileButton.disabled = true;
                cancelFileButton.disabled = true;
                micButton.disabled = false;
                progressContainer.style.display = 'none';
                progressBar.style.width = '0%';

                if (audioElement) {
                    audioElement.pause();
                    audioElement.currentTime = 0;
                    URL.revokeObjectURL(audioElement.src);
                }
                if (fileScriptProcessor) {
                    fileScriptProcessor.disconnect();
                }
                if (fileSource) {
                    fileSource.disconnect();
                }
                if (fileAudioContext) {
                    fileAudioContext.close();
                }
            }

            // Khởi tạo kết nối
            micButton.disabled = true;
            connectWebSocket();
        });
    </script>
</body>
</html>